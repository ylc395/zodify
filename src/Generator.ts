import * as t from "@babel/types";
import generate from "@babel/generator";
import fs from "fs-extra";
import { resolve, relative, parse as parsePath, isAbsolute, dirname } from "node:path";
import { camelCase, compact, groupBy } from "lodash-es";
import getCommonAncestorPath from "common-ancestor-path";

import type { Module, ImportInfo } from './types.js';
import { getFirstIdentifier } from "./utils.js";


export interface Config {
  modules: Module[];
  outDir: string; // absolute path
}

export default class Generator {
  private readonly commonAncestorPath: string;
  public readonly warnings = {
    shouldExport: [] as Array<{ path: Module['filePath'], typeName: string }>, 
    unknown: [] as Module['filePath'][]
  };

  constructor(private readonly config: Config) {
    const commonAncestorPath = getCommonAncestorPath(...config.modules.map(({ filePath: file }) => dirname(file)));

    if (!commonAncestorPath) {
      throw new Error('no common ancestor path');
    }

    if (!isAbsolute(config.outDir)) {
      throw new Error("outRoot must be an absolute path");
    }

    this.commonAncestorPath = commonAncestorPath;
  }


  public generate() {
    const outputs = this.config.modules.map(this.generateModule.bind(this));

    fs.emptyDirSync(this.config.outDir);

    for (const { code, file } of outputs) {
      fs.outputFileSync(file, code);
    }
  }

  private generateModule(module: Module) {
    const relativePath = relative(this.commonAncestorPath, module.filePath);
    const outputPath = resolve(this.config.outDir, relativePath);
    const schemas = this.generateSchemas(module);

    const statements = [
      schemas.length > 0 && t.importDeclaration(
        [t.importSpecifier(t.identifier('z'), t.identifier('z'))],
        t.stringLiteral('zod'),
      ),
      ...this.generateImports(Object.values(module.imports), outputPath),
      ...this.generateImports(module.reexports, outputPath, true),
      ...schemas,
    ];

    const program = t.program(compact(statements));
    t.addComment(program, 'leading', '\n* THIS FILE WAS GENERATED BY ZODIFY \n* DO NOT EDIT THIS FILE MANUALLY\n')
    const { code } = generate.default(program);

    return {
      code,
      file: outputPath,
    };
  }

  private generateImports(imports: ImportInfo[], outputPath: string, isReexport = false) {
    const importGroup = groupBy(imports, ({ path }) => path);

    return Object.entries(importGroup).flatMap(([path, importInfos]) => {
      let importPath = relative(relative(this.config.outDir, dirname(outputPath)), relative(this.commonAncestorPath, path));

      const ext = importInfos.find(({ ext }) => ext)?.ext || '';
      const { name, dir } = parsePath(importPath);

      importPath = `${dir || '.'}/${name}${ext}`

      const specifiers = importInfos
        .filter(({ origin, importFromSource }) => origin !== '*' && !importFromSource)
        .map(({ name, origin }) => {
          return (isReexport ? t.exportSpecifier : t.importSpecifier)(t.identifier(Generator.getSchemaName(name)), t.identifier(origin === 'default' ? 'default' : Generator.getSchemaName(origin)));
        }) as t.ExportSpecifier[] | t.ImportSpecifier[];

      const importStatement = specifiers.length > 0 && (
        isReexport 
          ? t.exportNamedDeclaration(null, specifiers as t.ExportSpecifier[], t.stringLiteral(importPath)) 
          : t.importDeclaration(specifiers as t.ImportSpecifier[], t.stringLiteral(importPath))
        );

      const namespace = importInfos.find(({ origin }) => origin === '*');
      const namespaceImportStatement = namespace && (
        isReexport 
          ? t.exportAllDeclaration(t.stringLiteral(importPath))
          : t.importDeclaration([t.importNamespaceSpecifier(t.identifier(namespace.name))], t.stringLiteral(importPath))
      );

      const importFromSourceSpecifiers = isReexport ? [] : importInfos
        .filter(({ importFromSource }) => importFromSource)
        .map(({ origin }) => {
          return t.importSpecifier(t.identifier(origin), t.identifier(origin));
        });

      let toSourcePath = relative(dirname(outputPath), path);

      const { dir: sourceDir, name: sourceName} = parsePath(toSourcePath);
      toSourcePath = `${sourceDir}/${sourceName}${ext}`

      const importFromSourceStatement = importFromSourceSpecifiers.length > 0 && t.importDeclaration(importFromSourceSpecifiers, t.stringLiteral(toSourcePath))

      return compact([namespaceImportStatement, importStatement, importFromSourceStatement]);
    });
  }

  private generateSchemas(module: Module) {
    const { topLevelTypes: types } = module;

    const statements = types.flatMap(({ ast, exported, exportedAsDefault }): t.Statement[] => {
      const declarationStatement = t.variableDeclaration('const', [t.variableDeclarator(t.identifier(Generator.getSchemaName(ast.id.name)), this.fromNode(ast, module))]);

      if (exported) {
        if (exportedAsDefault) {
          return [declarationStatement, t.exportDefaultDeclaration(t.identifier(Generator.getSchemaName(ast.id.name)))];
        }
        return [t.exportNamedDeclaration(declarationStatement)];
      } else if (t.isTSEnumDeclaration(ast)) {
        this.warnings.shouldExport.push({
          typeName: ast.id.name,
          path: module.filePath,
        })
      }

      return [declarationStatement];
    });

    return statements;
  }

  private static getSchemaName(originName: string) {
    return camelCase(`${originName}Schema`);
  }

  private static callZod(func: string, params?: t.Expression[]) {
    return t.callExpression(t.memberExpression(t.identifier('z'), t.identifier(func)), params || []);
  }

  private static readonly unknownSymbol = 'zodify_unknown';

  private getUnknown(filePath: string, concreteType?: string) {
    const result = Generator.callZod(concreteType || 'unknown')

    t.addComment(result, 'trailing', 'zodify can not transform type properly here');
    result.extra = {[Generator.unknownSymbol]: true};
    this.warnings.unknown.push(filePath);

    return result;
  }

  private fromNode(node: t.Node, module: Module, refine?: { zodFuncName: string, zodParams?: t.Expression[] }): t.Expression {
    if (t.isTSInterfaceDeclaration(node)) {
      return this.fromTSInterfaceDeclaration(node, module);
    }

    let result: t.Expression | undefined;

    if (t.isTSTypeAnnotation(node) || t.isTSTypeAliasDeclaration(node)) {
      result = this.fromNode(node.typeAnnotation, module);
    }

    if (t.isTSEnumDeclaration(node)) {
      result = Generator.callZod('nativeEnum', [t.identifier(node.id.name)])
    }

    if (t.isTSUnionType(node)) {
      result = Generator.callZod('union', [t.arrayExpression(node.types.map(t => this.fromNode(t, module)))])
    }

    if (t.isTSIntersectionType(node)) {
      result = Generator.callZod('intersection', node.types.map(t => this.fromNode(t, module)))
    }

    if (t.isTSArrayType(node)) {
      result = Generator.callZod('array', [this.fromNode(node.elementType, module)])
    }

    if (t.isTSTupleType(node)) {
      result = Generator.callZod('tuple', node.elementTypes.map(member => t.isTSNamedTupleMember(member) ? this.fromNode(member.elementType, module) : this.fromNode(member, module)));
    }

    if (t.isTSIndexedAccessType(node)) {
      result = this.fromTSIndexedAccessType(node, module)
    }

    if (t.isTSBaseType(node)) {
      result = t.isTSLiteralType(node) ? this.fromTSLiteralType(node, module) : this.fromTSBaseType(node, module);
    }

    if (t.isTSTypeReference(node)) {
      result = this.fromTSTypeReference(node, module)
    }

    if (t.isTSInterfaceBody(node) || t.isTSTypeLiteral(node)) {
      result = this.fromTSObject(node, module);
    }

    if (!result) {
      result = this.getUnknown(module.filePath);
    }

    if (refine && !result.extra?.[Generator.unknownSymbol]) {
      result = t.callExpression(t.memberExpression(result, t.identifier(refine.zodFuncName)), refine.zodParams || [])
    }

    return result;
  }

  private fromTSInterfaceDeclaration(node: t.TSInterfaceDeclaration, module: Module) {
    let result: t.Expression | undefined;

    if (node.extends) {
      for (const { expression, typeParameters } of node.extends) {
        if (typeParameters) {
          return this.getUnknown(module.filePath);
        }

        const expNode = this.fromTSEntityName(expression, module);

        if (expNode.extra?.[Generator.unknownSymbol]) {
          return expNode;
        }

        result = result ? t.callExpression(t.memberExpression(result, t.identifier('merge')), [expNode]) : expNode;
      }
    }

    const body = this.fromNode(node.body, module);
    result = result ? t.callExpression(t.memberExpression(result, t.identifier('merge')), [body]) : body;

    return result;
  }

  private fromTSObject(node: t.TSInterfaceBody | t.TSTypeLiteral, module: Module) {
    const members = t.isTSInterfaceBody(node) ? node.body : node.members;

    return Generator.callZod(
      'object',
      [t.objectExpression(compact(members.map((typeElement) => {
        if (!t.isTSPropertySignature(typeElement) || !typeElement.typeAnnotation) {
          return null;
        }

        return t.objectProperty(
          typeElement.key, 
          this.fromNode(typeElement.typeAnnotation, module, typeElement.optional ? { zodFuncName: 'optional' } : undefined),
        );
      })))],
    )
  }

  private fromTSTypeReference(node: t.TSTypeReference, module: Module) {
    const id = t.isIdentifier(node.typeName) ? node.typeName.name : getFirstIdentifier(node.typeName);

    // handle generics type
    if (node.typeParameters) {
      if (id === 'Array' || id === 'Set' || id === 'Map') {
        return Generator.callZod(id.toLowerCase(), node.typeParameters.params.map((p) => this.fromNode(p, module)));
      } 

      if (id === 'Required') {
        return Generator.callZod('array', node.typeParameters.params.map((p) => this.fromNode(p, module)));
      } 
      
      if (id === 'Required') {
        return this.fromNode(node.typeParameters.params[0], module, { zodFuncName: 'required' });
      } 
      
      if (id === 'Readonly') {
        return this.fromNode(node.typeParameters.params[0], module, { zodFuncName: 'readonly' });
      } 
      
      if (id === 'Partial') {
        return this.fromNode(node.typeParameters.params[0], module, { zodFuncName: 'partial' });
      } 
      
      if (id === 'Pick' || id === 'Omit') {
        const params = node.typeParameters.params[1];

        if (!params || (!t.isTSUnionType(params) && !t.isTSLiteralType(params))) {
          return this.getUnknown(module.filePath);
        }

        const types = t.isTSLiteralType(params) ? [params] : params.types;
        const literals = compact(types.map(p => t.isTSLiteralType(p) && t.isStringLiteral(p.literal) && p.literal));

        if (literals.length < types.length) {
          return this.getUnknown(module.filePath);
        }

        return this.fromNode(node.typeParameters.params[0], module, { 
          zodFuncName: id.toLowerCase(), 
          zodParams: [t.objectExpression(literals.map(({ value }) => t.objectProperty(t.stringLiteral(value), t.booleanLiteral(true))))],
        });
      } 
      
      if (id === 'Promise') {
        return Generator.callZod('promise', [this.fromNode(node.typeParameters.params[0], module)])
      } 
      
      if (id === 'Record') {
        return Generator.callZod('record', [this.fromNode(node.typeParameters.params[1], module)])
      } 
      
      return this.getUnknown(module.filePath);
    } else {
      return this.fromTSEntityName(node.typeName, module);
    }
  }

  private fromTSEntityName(node: t.TSEntityName, module: Module) {
    const id = t.isIdentifier(node) ? node.name : getFirstIdentifier(node);

    if (t.isIdentifier(node)) {
      if (!module.imports.find(({ name }) => name === id) && !module.topLevelTypes.find(({ ast }) => ast.id.name === id)) {
        return id === 'Date' ? Generator.callZod('date') : this.getUnknown(module.filePath);
      }
      return t.identifier(Generator.getSchemaName(id));
    } else {
      const isFirstNamespace = Boolean(module.imports.find(({ name, origin }) => origin === '*' && name === id));
      return this.fromTSQualifiedName(node, isFirstNamespace);
    }
  }

  private fromTSQualifiedName(node: t.TSQualifiedName, isFirstNamespace: boolean) {
    // In our view, a qualifiedName (like `a.b.c`) has no more than 3 identifier. 3 cases:
    // 1. `a.b`: `a` is an enum type
    // 2. `a.b`: `a` is a namespace
    // 3. `a.b.c`: `a` is a namespace and `b` is an enum type

    if (t.isIdentifier(node.left)) {
      // case 2 -- a.bSchema
      if (isFirstNamespace) {
        return t.memberExpression(t.identifier(node.left.name), t.identifier(Generator.getSchemaName(node.right.name)));
      }

      // case 1 -- z.literal(aSchema.enum.b)
      return Generator.callZod('literal', [t.memberExpression(t.memberExpression(t.identifier(Generator.getSchemaName(node.left.name)), t.identifier('enum')), t.identifier(node.right.name))]);
    } else {
      // unknown case
      if (!t.isIdentifier(node.left.left)) {
        return this.getUnknown(module.filename);
      }

      // case 3 -- z.literal(a.bSchema.enum.c)
      return Generator.callZod('literal', [t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(node.left.left.name), t.identifier(Generator.getSchemaName(node.left.right.name))), t.identifier('enum')), t.identifier(node.right.name))]);
    }
  }

  private fromTSBaseType(node: t.TSBaseType, module: Module) {
    if (t.isTSLiteralType(node)) {
      throw Error('unexpected: can not handle TSLiteralType')
    }

    if (t.isTSThisType(node) || t.isTSIntrinsicKeyword(node)) {
      return this.getUnknown(module.filePath);
    }

    if (t.isTSObjectKeyword(node)) {
      // z.object({}).passthrough()
      // https://github.com/jbranchaud/til/blob/master/zod/create-a-schema-that-matches-on-any-object.md
      return t.callExpression(t.memberExpression(
        Generator.callZod('object', [t.objectExpression([])]),
        t.identifier('passthrough')), 
        [],
      );
    }

    const zodFuncs = {
      TSStringKeyword: 'string',
      TSNumberKeyword: 'number',
      TSBigIntKeyword: 'bigint',
      TSBooleanKeyword: 'boolean',
      TSSymbolKeyword: 'symbol',
      TSUndefinedKeyword: 'undefined',
      TSNullKeyword: 'null',
      TSVoidKeyword: 'void',
      TSAnyKeyword: 'any',
      TSUnknownKeyword: 'unknown',
      TSNeverKeyword: 'never',
    };

    return Generator.callZod(zodFuncs[node.type]);
  }
  
  private fromTSLiteralType(node: t.TSLiteralType, module: Module) {
    const { literal } = node;

    if (t.isTemplateLiteral(literal) || t.isUnaryExpression(literal)) {
      return this.getUnknown(module.filePath, 'string');
    }

    const literalFuncs = {
      StringLiteral: t.stringLiteral,
      BooleanLiteral: t.booleanLiteral,
      NumericLiteral: t.numericLiteral,
      BigIntLiteral: t.bigIntLiteral,
    };

    const zodParam = (literalFuncs[literal.type] as any)(literal.value);
    return Generator.callZod('literal', [zodParam]);
  }

  private fromTSIndexedAccessType({ objectType, indexType }: t.TSIndexedAccessType, module: Module) {
    if (!t.isTSLiteralType(indexType) || !t.isStringLiteral(indexType.literal)) {
      return this.getUnknown(module.filePath);
    }

    const obj = this.fromNode(objectType, module);

    if (obj.extra?.[Generator.unknownSymbol]) {
      return obj;
    }

    return t.memberExpression(t.memberExpression(obj, t.identifier('shape')), t.stringLiteral(indexType.literal.value), true);
  }
}
